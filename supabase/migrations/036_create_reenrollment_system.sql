-- =====================================================
-- MIGRATION 036: SISTEMA DE REMATRÍCULA AUTOMÁTICA
-- =====================================================
-- Implementa a lógica de rematrícula de alunos para o
-- próximo ano letivo, executada pelo Coordenador ou
-- Administrativo da escola após o fechamento do ano.
--
-- Regras:
-- - Aprovados: avançam de série
-- - Reprovados: mantêm a série
-- - Concluíram ciclo: não rematricula (status Concluído)
-- - Se escola não tem série: busca outra do polo
-- =====================================================

-- =====================================================
-- 1. CRIAR ENUM PARA STATUS DE REMATRÍCULA
-- =====================================================

DO $$ BEGIN
  CREATE TYPE reenrollment_status AS ENUM (
    'Pendente',           -- Lote criado, aguardando execução
    'Em_Processamento',   -- Executando rematrícula
    'Concluido',          -- Rematrícula finalizada
    'Cancelado'           -- Cancelado antes de executar
  );
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE reenrollment_item_status AS ENUM (
    'Pendente',           -- Aguardando processamento
    'Rematriculado',      -- Rematrícula criada com sucesso
    'Concluido_Ciclo',    -- Não rematricula - concluiu o ciclo
    'Necessita_Escola',   -- Precisa definir escola destino
    'Erro',               -- Erro no processamento
    'Excluido'            -- Removido do lote pelo usuário
  );
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

DO $$ BEGIN
  CREATE TYPE student_final_result AS ENUM (
    'Aprovado',
    'Reprovado',
    'Aprovado_Conselho',
    'Concluido',
    'Desistente',
    'Transferido'
  );
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- 2. ADICIONAR COLUNAS EM student_enrollments
-- =====================================================

-- Status de rematriculado
DO $$ BEGIN
  ALTER TYPE student_enrollment_status ADD VALUE IF NOT EXISTS 'Rematriculado';
  ALTER TYPE student_enrollment_status ADD VALUE IF NOT EXISTS 'Concluido';
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

-- Resultado final do ano e série
ALTER TABLE student_enrollments
  ADD COLUMN IF NOT EXISTS resultado_final student_final_result,
  ADD COLUMN IF NOT EXISTS serie VARCHAR(20),
  ADD COLUMN IF NOT EXISTS rematricula_origem_id INTEGER;

COMMENT ON COLUMN student_enrollments.resultado_final IS 'Resultado final do aluno no ano letivo (Aprovado, Reprovado, etc).';
COMMENT ON COLUMN student_enrollments.serie IS 'Série/Ano do aluno (ex: 1º Ano, 5º Ano, 9º Ano).';
COMMENT ON COLUMN student_enrollments.rematricula_origem_id IS 'ID da matrícula do ano anterior (para rastrear histórico).';

-- Índice
CREATE INDEX IF NOT EXISTS idx_enrollments_resultado ON student_enrollments(resultado_final);
CREATE INDEX IF NOT EXISTS idx_enrollments_serie ON student_enrollments(serie);

-- =====================================================
-- 3. CRIAR TABELA DE SÉRIES/ANOS POR NÍVEL
-- =====================================================

CREATE TABLE IF NOT EXISTS education_grades (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  education_level VARCHAR(50) NOT NULL,  -- Infantil, Fundamental I, Fundamental II, Médio, EJA
  grade_name VARCHAR(20) NOT NULL,        -- 1º Ano, 2º Ano, etc
  grade_order INTEGER NOT NULL,           -- Ordem sequencial
  is_final_grade BOOLEAN DEFAULT FALSE,   -- É a última série do nível?
  next_grade_id INTEGER,                  -- Próxima série (NULL se final)
  created_at TIMESTAMP NOT NULL DEFAULT now(),
  UNIQUE(education_level, grade_name)
);

-- Índices
CREATE INDEX IF NOT EXISTS idx_education_grades_level ON education_grades(education_level);
CREATE INDEX IF NOT EXISTS idx_education_grades_order ON education_grades(grade_order);

COMMENT ON TABLE education_grades IS 'Define as séries/anos de cada nível de ensino e a progressão entre elas.';

-- Inserir séries padrão
INSERT INTO education_grades (education_level, grade_name, grade_order, is_final_grade) VALUES
-- Educação Infantil
('Infantil', 'Berçário', 1, FALSE),
('Infantil', 'Maternal I', 2, FALSE),
('Infantil', 'Maternal II', 3, FALSE),
('Infantil', 'Pré I', 4, FALSE),
('Infantil', 'Pré II', 5, TRUE),

-- Fundamental I
('Fundamental I', '1º Ano', 1, FALSE),
('Fundamental I', '2º Ano', 2, FALSE),
('Fundamental I', '3º Ano', 3, FALSE),
('Fundamental I', '4º Ano', 4, FALSE),
('Fundamental I', '5º Ano', 5, TRUE),

-- Fundamental II
('Fundamental II', '6º Ano', 1, FALSE),
('Fundamental II', '7º Ano', 2, FALSE),
('Fundamental II', '8º Ano', 3, FALSE),
('Fundamental II', '9º Ano', 4, TRUE),

-- Ensino Médio
('Médio', '1ª Série', 1, FALSE),
('Médio', '2ª Série', 2, FALSE),
('Médio', '3ª Série', 3, TRUE),

-- EJA
('EJA', 'EJA Fundamental I', 1, TRUE),
('EJA', 'EJA Fundamental II', 2, TRUE),
('EJA', 'EJA Médio', 3, TRUE)
ON CONFLICT (education_level, grade_name) DO NOTHING;

-- Atualizar próximas séries
UPDATE education_grades SET next_grade_id = (
  SELECT id FROM education_grades g2
  WHERE g2.education_level = education_grades.education_level
    AND g2.grade_order = education_grades.grade_order + 1
);

-- =====================================================
-- 4. CRIAR TABELA DE NÍVEIS OFERECIDOS POR ESCOLA
-- =====================================================

CREATE TABLE IF NOT EXISTS school_education_levels (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  school_id INTEGER NOT NULL,
  education_level VARCHAR(50) NOT NULL,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP NOT NULL DEFAULT now(),
  UNIQUE(school_id, education_level)
);

ALTER TABLE school_education_levels
  ADD CONSTRAINT fk_school_education_levels_school
  FOREIGN KEY (school_id) REFERENCES schools(id)
  ON DELETE CASCADE;

COMMENT ON TABLE school_education_levels IS 'Define quais níveis de ensino cada escola oferece.';

-- =====================================================
-- 5. CRIAR TABELA DE LOTES DE REMATRÍCULA
-- =====================================================

CREATE TABLE IF NOT EXISTS reenrollment_batches (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  -- Identificação
  school_id INTEGER NOT NULL,
  ano_letivo_origem_id INTEGER NOT NULL,
  ano_letivo_destino_id INTEGER NOT NULL,

  -- Status
  status reenrollment_status NOT NULL DEFAULT 'Pendente',

  -- Contadores
  total_alunos INTEGER DEFAULT 0,
  total_rematriculados INTEGER DEFAULT 0,
  total_concluidos INTEGER DEFAULT 0,
  total_pendentes INTEGER DEFAULT 0,
  total_erros INTEGER DEFAULT 0,

  -- Datas
  data_criacao TIMESTAMP NOT NULL DEFAULT now(),
  data_execucao TIMESTAMP,
  data_conclusao TIMESTAMP,

  -- Responsável
  criado_por INTEGER NOT NULL,
  executado_por INTEGER,

  -- Observações
  observacoes TEXT,

  -- Auditoria
  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP NOT NULL DEFAULT now(),
  created_by INTEGER NOT NULL DEFAULT 1,
  updated_by INTEGER,
  deleted_at TIMESTAMP
);

-- Índices
CREATE INDEX IF NOT EXISTS idx_reenrollment_batches_school ON reenrollment_batches(school_id);
CREATE INDEX IF NOT EXISTS idx_reenrollment_batches_status ON reenrollment_batches(status);
CREATE INDEX IF NOT EXISTS idx_reenrollment_batches_ano_origem ON reenrollment_batches(ano_letivo_origem_id);

-- Foreign Keys
ALTER TABLE reenrollment_batches
  ADD CONSTRAINT fk_reenrollment_batches_school
  FOREIGN KEY (school_id) REFERENCES schools(id);

ALTER TABLE reenrollment_batches
  ADD CONSTRAINT fk_reenrollment_batches_ano_origem
  FOREIGN KEY (ano_letivo_origem_id) REFERENCES academic_years(id);

ALTER TABLE reenrollment_batches
  ADD CONSTRAINT fk_reenrollment_batches_ano_destino
  FOREIGN KEY (ano_letivo_destino_id) REFERENCES academic_years(id);

ALTER TABLE reenrollment_batches
  ADD CONSTRAINT fk_reenrollment_batches_criado_por
  FOREIGN KEY (criado_por) REFERENCES people(id);

COMMENT ON TABLE reenrollment_batches IS 'Registra os lotes de rematrícula executados por escola/ano.';

-- Trigger
CREATE TRIGGER set_reenrollment_batches_updated_at
  BEFORE UPDATE ON reenrollment_batches
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at();

-- =====================================================
-- 6. CRIAR TABELA DE ITENS DE REMATRÍCULA
-- =====================================================

CREATE TABLE IF NOT EXISTS reenrollment_items (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  -- Vínculo com lote
  batch_id INTEGER NOT NULL,

  -- Aluno
  student_profile_id INTEGER NOT NULL,
  matricula_origem_id INTEGER NOT NULL,

  -- Situação atual
  serie_atual VARCHAR(20) NOT NULL,
  resultado_final student_final_result,

  -- Destino calculado
  serie_destino VARCHAR(20),
  escola_destino_id INTEGER,
  escola_destino_sugerida BOOLEAN DEFAULT FALSE,  -- Sistema sugeriu outra escola?

  -- Status do item
  status reenrollment_item_status NOT NULL DEFAULT 'Pendente',
  motivo_status TEXT,

  -- Resultado
  matricula_destino_id INTEGER,

  -- Auditoria
  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP NOT NULL DEFAULT now()
);

-- Índices
CREATE INDEX IF NOT EXISTS idx_reenrollment_items_batch ON reenrollment_items(batch_id);
CREATE INDEX IF NOT EXISTS idx_reenrollment_items_student ON reenrollment_items(student_profile_id);
CREATE INDEX IF NOT EXISTS idx_reenrollment_items_status ON reenrollment_items(status);

-- Foreign Keys
ALTER TABLE reenrollment_items
  ADD CONSTRAINT fk_reenrollment_items_batch
  FOREIGN KEY (batch_id) REFERENCES reenrollment_batches(id)
  ON DELETE CASCADE;

ALTER TABLE reenrollment_items
  ADD CONSTRAINT fk_reenrollment_items_student
  FOREIGN KEY (student_profile_id) REFERENCES student_profiles(id);

ALTER TABLE reenrollment_items
  ADD CONSTRAINT fk_reenrollment_items_matricula_origem
  FOREIGN KEY (matricula_origem_id) REFERENCES student_enrollments(id);

ALTER TABLE reenrollment_items
  ADD CONSTRAINT fk_reenrollment_items_escola_destino
  FOREIGN KEY (escola_destino_id) REFERENCES schools(id);

ALTER TABLE reenrollment_items
  ADD CONSTRAINT fk_reenrollment_items_matricula_destino
  FOREIGN KEY (matricula_destino_id) REFERENCES student_enrollments(id);

COMMENT ON TABLE reenrollment_items IS 'Itens individuais de cada lote de rematrícula, um por aluno.';

-- Trigger
CREATE TRIGGER set_reenrollment_items_updated_at
  BEFORE UPDATE ON reenrollment_items
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at();

-- =====================================================
-- 7. FUNÇÕES DE REMATRÍCULA
-- =====================================================

-- Função para obter próxima série
CREATE OR REPLACE FUNCTION fn_get_proxima_serie(
  p_serie_atual VARCHAR,
  p_resultado student_final_result
)
RETURNS TABLE (
  proxima_serie VARCHAR,
  is_final BOOLEAN,
  education_level VARCHAR
) AS $$
BEGIN
  -- Se reprovado, mantém a mesma série
  IF p_resultado = 'Reprovado' THEN
    RETURN QUERY
    SELECT
      eg.grade_name::VARCHAR,
      eg.is_final_grade,
      eg.education_level::VARCHAR
    FROM education_grades eg
    WHERE eg.grade_name = p_serie_atual;
    RETURN;
  END IF;

  -- Se aprovado ou aprovado por conselho, avança
  IF p_resultado IN ('Aprovado', 'Aprovado_Conselho') THEN
    RETURN QUERY
    SELECT
      COALESCE(eg_next.grade_name, eg.grade_name)::VARCHAR as proxima_serie,
      eg.is_final_grade,
      eg.education_level::VARCHAR
    FROM education_grades eg
    LEFT JOIN education_grades eg_next ON eg_next.id = eg.next_grade_id
    WHERE eg.grade_name = p_serie_atual;
    RETURN;
  END IF;

  -- Outros casos (Concluído, Desistente, Transferido) não avançam
  RETURN QUERY
  SELECT
    eg.grade_name::VARCHAR,
    TRUE::BOOLEAN,
    eg.education_level::VARCHAR
  FROM education_grades eg
  WHERE eg.grade_name = p_serie_atual;
END;
$$ LANGUAGE plpgsql;

-- Função para buscar escola alternativa no polo
CREATE OR REPLACE FUNCTION fn_buscar_escola_alternativa(
  p_escola_atual_id INTEGER,
  p_education_level VARCHAR
)
RETURNS TABLE (
  school_id INTEGER,
  school_name VARCHAR,
  polo_id INTEGER,
  vagas_disponiveis INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    s.id as school_id,
    s.name::VARCHAR as school_name,
    s.polo_id,
    COALESCE(s.student_capacity - (
      SELECT COUNT(*) FROM student_enrollments se
      WHERE se.school_id = s.id
        AND se.enrollment_status = 'Ativo'
        AND se.deleted_at IS NULL
    ), 0)::INTEGER as vagas_disponiveis
  FROM schools s
  JOIN school_education_levels sel ON sel.school_id = s.id
  WHERE sel.education_level = p_education_level
    AND sel.is_active = TRUE
    AND s.id != p_escola_atual_id
    AND s.polo_id = (SELECT polo_id FROM schools WHERE id = p_escola_atual_id)
    AND s.deleted_at IS NULL
  ORDER BY vagas_disponiveis DESC;
END;
$$ LANGUAGE plpgsql;

-- Função para criar lote de rematrícula
CREATE OR REPLACE FUNCTION fn_criar_lote_rematricula(
  p_school_id INTEGER,
  p_ano_origem_id INTEGER,
  p_ano_destino_id INTEGER,
  p_criado_por INTEGER
)
RETURNS INTEGER AS $$
DECLARE
  v_batch_id INTEGER;
  v_enrollment RECORD;
  v_proxima_serie RECORD;
  v_escola_destino INTEGER;
  v_status reenrollment_item_status;
  v_total INTEGER := 0;
  v_total_concluidos INTEGER := 0;
  v_total_pendentes INTEGER := 0;
BEGIN
  -- Verificar se já existe lote pendente
  IF EXISTS (
    SELECT 1 FROM reenrollment_batches
    WHERE school_id = p_school_id
      AND ano_letivo_origem_id = p_ano_origem_id
      AND ano_letivo_destino_id = p_ano_destino_id
      AND status IN ('Pendente', 'Em_Processamento')
      AND deleted_at IS NULL
  ) THEN
    RAISE EXCEPTION 'Já existe um lote de rematrícula pendente para esta escola/ano';
  END IF;

  -- Criar lote
  INSERT INTO reenrollment_batches (
    school_id,
    ano_letivo_origem_id,
    ano_letivo_destino_id,
    status,
    criado_por,
    created_by
  ) VALUES (
    p_school_id,
    p_ano_origem_id,
    p_ano_destino_id,
    'Pendente',
    p_criado_por,
    p_criado_por
  )
  RETURNING id INTO v_batch_id;

  -- Processar cada aluno ativo no ano de origem
  FOR v_enrollment IN (
    SELECT
      se.id,
      se.student_profile_id,
      se.serie,
      se.resultado_final,
      se.school_id
    FROM student_enrollments se
    WHERE se.school_id = p_school_id
      AND se.academic_year_id = p_ano_origem_id
      AND se.enrollment_status = 'Ativo'
      AND se.deleted_at IS NULL
  )
  LOOP
    v_total := v_total + 1;

    -- Calcular próxima série
    SELECT * INTO v_proxima_serie
    FROM fn_get_proxima_serie(
      COALESCE(v_enrollment.serie, '1º Ano'),
      COALESCE(v_enrollment.resultado_final, 'Aprovado')
    );

    -- Verificar se concluiu o ciclo
    IF v_proxima_serie.is_final AND v_enrollment.resultado_final IN ('Aprovado', 'Aprovado_Conselho') THEN
      v_status := 'Concluido_Ciclo';
      v_escola_destino := NULL;
      v_total_concluidos := v_total_concluidos + 1;
    -- Verificar se escola tem o nível da próxima série
    ELSIF NOT EXISTS (
      SELECT 1 FROM school_education_levels
      WHERE school_id = p_school_id
        AND education_level = v_proxima_serie.education_level
        AND is_active = TRUE
    ) THEN
      -- Buscar escola alternativa
      SELECT s.school_id INTO v_escola_destino
      FROM fn_buscar_escola_alternativa(p_school_id, v_proxima_serie.education_level) s
      LIMIT 1;

      IF v_escola_destino IS NOT NULL THEN
        v_status := 'Necessita_Escola';
        v_total_pendentes := v_total_pendentes + 1;
      ELSE
        v_status := 'Necessita_Escola';
        v_total_pendentes := v_total_pendentes + 1;
      END IF;
    ELSE
      v_status := 'Pendente';
      v_escola_destino := p_school_id;
    END IF;

    -- Não processa transferidos ou desistentes
    IF v_enrollment.resultado_final IN ('Transferido', 'Desistente') THEN
      v_status := 'Excluido';
    END IF;

    -- Inserir item
    INSERT INTO reenrollment_items (
      batch_id,
      student_profile_id,
      matricula_origem_id,
      serie_atual,
      resultado_final,
      serie_destino,
      escola_destino_id,
      escola_destino_sugerida,
      status
    ) VALUES (
      v_batch_id,
      v_enrollment.student_profile_id,
      v_enrollment.id,
      COALESCE(v_enrollment.serie, '1º Ano'),
      v_enrollment.resultado_final,
      v_proxima_serie.proxima_serie,
      v_escola_destino,
      v_escola_destino != p_school_id,
      v_status
    );
  END LOOP;

  -- Atualizar contadores do lote
  UPDATE reenrollment_batches SET
    total_alunos = v_total,
    total_concluidos = v_total_concluidos,
    total_pendentes = v_total_pendentes
  WHERE id = v_batch_id;

  RETURN v_batch_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para executar rematrícula de um item
CREATE OR REPLACE FUNCTION fn_executar_rematricula_item(
  p_item_id INTEGER,
  p_executado_por INTEGER
)
RETURNS INTEGER AS $$
DECLARE
  v_item RECORD;
  v_batch RECORD;
  v_nova_matricula_id INTEGER;
BEGIN
  -- Buscar item
  SELECT * INTO v_item FROM reenrollment_items WHERE id = p_item_id;

  IF v_item IS NULL THEN
    RAISE EXCEPTION 'Item de rematrícula não encontrado';
  END IF;

  IF v_item.status NOT IN ('Pendente', 'Necessita_Escola') THEN
    RAISE EXCEPTION 'Item não está pendente para rematrícula';
  END IF;

  IF v_item.escola_destino_id IS NULL THEN
    RAISE EXCEPTION 'Escola destino não definida';
  END IF;

  -- Buscar batch
  SELECT * INTO v_batch FROM reenrollment_batches WHERE id = v_item.batch_id;

  -- Criar nova matrícula
  INSERT INTO student_enrollments (
    student_profile_id,
    school_id,
    academic_year_id,
    course_id,
    enrollment_status,
    enrollment_date,
    serie,
    rematricula_origem_id,
    created_by
  )
  SELECT
    v_item.student_profile_id,
    v_item.escola_destino_id,
    v_batch.ano_letivo_destino_id,
    se.course_id,
    'Ativo',
    now(),
    v_item.serie_destino,
    v_item.matricula_origem_id,
    p_executado_por
  FROM student_enrollments se
  WHERE se.id = v_item.matricula_origem_id
  RETURNING id INTO v_nova_matricula_id;

  -- Atualizar matrícula origem
  UPDATE student_enrollments SET
    enrollment_status = 'Rematriculado',
    updated_at = now()
  WHERE id = v_item.matricula_origem_id;

  -- Atualizar item
  UPDATE reenrollment_items SET
    status = 'Rematriculado',
    matricula_destino_id = v_nova_matricula_id,
    updated_at = now()
  WHERE id = p_item_id;

  RETURN v_nova_matricula_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para executar lote completo
CREATE OR REPLACE FUNCTION fn_executar_lote_rematricula(
  p_batch_id INTEGER,
  p_executado_por INTEGER
)
RETURNS TABLE (
  total_processados INTEGER,
  total_sucesso INTEGER,
  total_erros INTEGER
) AS $$
DECLARE
  v_item RECORD;
  v_total_processados INTEGER := 0;
  v_total_sucesso INTEGER := 0;
  v_total_erros INTEGER := 0;
BEGIN
  -- Marcar lote como em processamento
  UPDATE reenrollment_batches SET
    status = 'Em_Processamento',
    data_execucao = now(),
    executado_por = p_executado_por
  WHERE id = p_batch_id;

  -- Processar cada item pendente
  FOR v_item IN (
    SELECT id FROM reenrollment_items
    WHERE batch_id = p_batch_id
      AND status = 'Pendente'
      AND escola_destino_id IS NOT NULL
  )
  LOOP
    v_total_processados := v_total_processados + 1;

    BEGIN
      PERFORM fn_executar_rematricula_item(v_item.id, p_executado_por);
      v_total_sucesso := v_total_sucesso + 1;
    EXCEPTION WHEN OTHERS THEN
      UPDATE reenrollment_items SET
        status = 'Erro',
        motivo_status = SQLERRM
      WHERE id = v_item.id;
      v_total_erros := v_total_erros + 1;
    END;
  END LOOP;

  -- Atualizar contadores do lote
  UPDATE reenrollment_batches SET
    status = 'Concluido',
    data_conclusao = now(),
    total_rematriculados = v_total_sucesso,
    total_erros = v_total_erros
  WHERE id = p_batch_id;

  RETURN QUERY SELECT v_total_processados, v_total_sucesso, v_total_erros;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para definir escola de um item
CREATE OR REPLACE FUNCTION fn_definir_escola_item(
  p_item_id INTEGER,
  p_escola_id INTEGER
)
RETURNS BOOLEAN AS $$
BEGIN
  UPDATE reenrollment_items SET
    escola_destino_id = p_escola_id,
    escola_destino_sugerida = FALSE,
    status = 'Pendente',
    updated_at = now()
  WHERE id = p_item_id
    AND status = 'Necessita_Escola';

  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- 8. VIEW PARA PRÉVIA DE REMATRÍCULA
-- =====================================================

CREATE OR REPLACE VIEW vw_previa_rematricula AS
SELECT
  se.school_id,
  s.name as school_name,
  se.academic_year_id,
  ay.year_name as ano_letivo,
  se.id as enrollment_id,
  sp.id as student_profile_id,
  p.first_name || ' ' || p.last_name as student_name,
  se.serie as serie_atual,
  se.resultado_final,
  CASE
    WHEN se.resultado_final = 'Reprovado' THEN se.serie
    WHEN se.resultado_final IN ('Aprovado', 'Aprovado_Conselho') THEN (
      SELECT COALESCE(eg_next.grade_name, eg.grade_name)
      FROM education_grades eg
      LEFT JOIN education_grades eg_next ON eg_next.id = eg.next_grade_id
      WHERE eg.grade_name = se.serie
    )
    ELSE se.serie
  END as serie_destino,
  CASE
    WHEN eg.is_final_grade AND se.resultado_final IN ('Aprovado', 'Aprovado_Conselho') THEN TRUE
    ELSE FALSE
  END as concluiu_ciclo,
  CASE
    WHEN NOT EXISTS (
      SELECT 1 FROM school_education_levels sel
      WHERE sel.school_id = se.school_id
        AND sel.education_level = (
          SELECT eg2.education_level
          FROM education_grades eg2
          LEFT JOIN education_grades eg_next ON eg_next.id = eg2.next_grade_id
          WHERE eg2.grade_name = se.serie
        )
        AND sel.is_active = TRUE
    ) THEN TRUE
    ELSE FALSE
  END as precisa_trocar_escola
FROM student_enrollments se
JOIN student_profiles sp ON sp.id = se.student_profile_id
JOIN people p ON p.id = sp.person_id
JOIN schools s ON s.id = se.school_id
JOIN academic_years ay ON ay.id = se.academic_year_id
LEFT JOIN education_grades eg ON eg.grade_name = se.serie
WHERE se.enrollment_status = 'Ativo'
  AND se.deleted_at IS NULL;

COMMENT ON VIEW vw_previa_rematricula IS 'Prévia de rematrícula mostrando situação de cada aluno.';

-- =====================================================
-- 9. RLS PARA TABELAS DE REMATRÍCULA
-- =====================================================

ALTER TABLE reenrollment_batches ENABLE ROW LEVEL SECURITY;
ALTER TABLE reenrollment_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE education_grades ENABLE ROW LEVEL SECURITY;
ALTER TABLE school_education_levels ENABLE ROW LEVEL SECURITY;

-- Policies para Admin
CREATE POLICY "Admin pode gerenciar reenrollment_batches"
  ON reenrollment_batches FOR ALL
  TO authenticated
  USING (check_user_is_admin(auth.uid()));

CREATE POLICY "Admin pode gerenciar reenrollment_items"
  ON reenrollment_items FOR ALL
  TO authenticated
  USING (check_user_is_admin(auth.uid()));

CREATE POLICY "Admin pode gerenciar education_grades"
  ON education_grades FOR ALL
  TO authenticated
  USING (check_user_is_admin(auth.uid()));

CREATE POLICY "Admin pode gerenciar school_education_levels"
  ON school_education_levels FOR ALL
  TO authenticated
  USING (check_user_is_admin(auth.uid()));

-- Policies para escola
CREATE POLICY "Escola pode ver seus lotes"
  ON reenrollment_batches FOR SELECT
  TO authenticated
  USING (
    school_id IN (
      SELECT school_id FROM user_school_roles
      WHERE person_id = (SELECT person_id FROM auth_users WHERE id = auth.uid())
        AND deleted_at IS NULL
    )
  );

CREATE POLICY "Escola pode ver itens dos seus lotes"
  ON reenrollment_items FOR SELECT
  TO authenticated
  USING (
    batch_id IN (
      SELECT id FROM reenrollment_batches
      WHERE school_id IN (
        SELECT school_id FROM user_school_roles
        WHERE person_id = (SELECT person_id FROM auth_users WHERE id = auth.uid())
          AND deleted_at IS NULL
      )
    )
  );

-- Todos podem ver séries
CREATE POLICY "Todos podem ver education_grades"
  ON education_grades FOR SELECT
  TO authenticated
  USING (TRUE);

-- Todos podem ver níveis das escolas
CREATE POLICY "Todos podem ver school_education_levels"
  ON school_education_levels FOR SELECT
  TO authenticated
  USING (TRUE);

-- =====================================================
-- FIM DA MIGRATION 036
-- =====================================================
-- Resumo:
-- - ENUMs: reenrollment_status, reenrollment_item_status, student_final_result
-- - Tabelas: education_grades, school_education_levels, reenrollment_batches, reenrollment_items
-- - Colunas em student_enrollments: resultado_final, serie, rematricula_origem_id
-- - Funções:
--   - fn_get_proxima_serie() - Calcula próxima série
--   - fn_buscar_escola_alternativa() - Busca escola no polo
--   - fn_criar_lote_rematricula() - Cria lote com prévia
--   - fn_executar_rematricula_item() - Executa item individual
--   - fn_executar_lote_rematricula() - Executa lote completo
--   - fn_definir_escola_item() - Define escola para item pendente
-- - View: vw_previa_rematricula
-- - RLS configurado para todas as tabelas
-- =====================================================
