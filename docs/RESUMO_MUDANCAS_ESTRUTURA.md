# Resumo das Mudanças na Estrutura do Banco de Dados

## Contexto
Desde a criação inicial do frontend até a geração do banco de dados no Supabase, houve mudanças na estrutura do banco. Este documento resume essas mudanças e o que foi implementado.

---

## Mudanças Implementadas

### 1. Enum `entity_type` ✅
**Status**: Já existia na migração `002_create_enums.sql`

**Valores**:
- `school`
- `infrastructure`
- `person`
- `student_profile`
- `guardian`
- `student_enrollment`
- `teacher`
- `position`
- `department`
- `staff`
- `academic_year`
- `academic_period`
- `course`
- `subject`
- `class`
- `lesson`
- `evaluation_instance`
- `grade`
- `attendance`
- `school_document`
- `communication`
- `secretariat_protocol`
- `public_portal_content`
- `system_setting`
- `role`
- `permission`
- `incident_type`
- `incident`
- `disciplinary_action`
- `school_event`
- E outros...

**Uso**: Categoriza as entidades às quais os anexos podem ser relacionados.

---

### 2. Tabela `attachments` ✅
**Status**: Migrações criadas

**Migrações**:
- `026_create_attachments_table.sql` - Criação da tabela
- `027_configure_rls_attachments.sql` - Configuração de RLS

**Estrutura**:
```sql
CREATE TABLE attachments (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  entity_type entity_type NOT NULL,
  entity_id INTEGER NOT NULL,
  file_name VARCHAR(255) NOT NULL,
  file_path_url VARCHAR(500) NOT NULL,
  file_type VARCHAR(50) NOT NULL,
  file_size_bytes INTEGER,
  description TEXT,
  uploaded_by_id INTEGER NOT NULL,
  uploaded_at TIMESTAMP NOT NULL DEFAULT now(),
  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP NOT NULL DEFAULT now(),
  created_by INTEGER NOT NULL,
  updated_by INTEGER,
  deleted_at TIMESTAMP
);
```

**Índices**:
- `idx_attachments_entity` em `(entity_type, entity_id)`
- `idx_attachments_uploaded_by` em `uploaded_by_id`
- `idx_attachments_deleted_at` em `deleted_at` (WHERE deleted_at IS NULL)
- `idx_attachments_file_type` em `file_type`

**Foreign Keys**:
- `uploaded_by_id` → `people.id`
- `created_by` → `people.id`
- `updated_by` → `people.id`

**RLS Policies**:
- **SELECT**: Usuários podem ver anexos de entidades que têm acesso
- **INSERT**: Usuários autenticados podem criar anexos
- **UPDATE**: Usuários podem atualizar seus próprios anexos ou admin pode atualizar qualquer um
- **DELETE**: Usuários podem excluir seus próprios anexos ou admin pode excluir qualquer um

---

## Próximos Passos

### 1. Aplicar Migrações no Supabase
```bash
# Via Supabase Dashboard ou CLI
supabase db push
```

### 2. Regenerar Tipos TypeScript
```bash
npx supabase gen types typescript --project-id "seu-project-id" > src/lib/supabase/database.types.ts
```

### 3. Criar Serviço para Attachments
- Criar `src/lib/supabase/services/attachment-service.ts`
- Implementar métodos:
  - `uploadAttachment(file, entityType, entityId)`
  - `getAttachmentsByEntity(entityType, entityId)`
  - `deleteAttachment(id)`
  - `getAttachmentById(id)`

### 4. Integrar com Supabase Storage
- Configurar buckets no Supabase Storage
- Implementar upload de arquivos
- Gerar URLs públicas/privadas
- Configurar políticas de Storage

### 5. Criar Componentes de UI
- Componente para upload de arquivos
- Componente para visualizar anexos
- Integração em formulários relevantes (perfil de aluno, escola, etc.)

---

## Documentação Relacionada

- `docs/ATUALIZACAO_ATTACHMENTS.md` - Detalhes completos sobre a implementação
- `supabase/migrations/026_create_attachments_table.sql` - Migração da tabela
- `supabase/migrations/027_configure_rls_attachments.sql` - Políticas RLS

---

## Notas Importantes

1. **Storage**: A tabela `attachments` armazena apenas metadados. Os arquivos físicos devem ser armazenados no Supabase Storage ou em outro serviço de armazenamento.

2. **Segurança**: As políticas RLS garantem que usuários só vejam anexos de entidades que têm acesso, mas é importante também configurar políticas de Storage no Supabase.

3. **Performance**: O índice em `(entity_type, entity_id)` otimiza buscas por entidade específica.

4. **Soft Delete**: A tabela usa `deleted_at` para soft delete, permitindo recuperação de dados se necessário.

5. **Flexibilidade**: O design genérico permite associar anexos a qualquer entidade do sistema sem precisar criar tabelas específicas para cada tipo.

